// This is your Prisma schema file for PostgreSQL
// Learn more: https://pris.ly/d/prisma-schema

generator client {
    provider = "prisma-client-js"
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

model User {
    id                     String    @id @default(cuid())
    email                  String    @unique
    emailVerified          DateTime?
    password               String? // Hashed password
    name                   String?
    username               String?   @unique
    image                  String?
    planId                 String    @default("free")
    stripeCustomerId       String?   @unique
    stripeSubscriptionId   String?   @unique
    stripePriceId          String?
    stripeCurrentPeriodEnd DateTime?
    createdAt              DateTime  @default(now())
    updatedAt              DateTime  @updatedAt

    profile  Profile?
    accounts Account[]
    sessions Session[]

    @@index([email])
    @@index([username])
}

model Account {
    id                String  @id @default(cuid())
    userId            String
    type              String
    provider          String
    providerAccountId String
    refresh_token     String? @db.Text
    access_token      String? @db.Text
    expires_at        Int?
    token_type        String?
    scope             String?
    id_token          String? @db.Text
    session_state     String?

    user User @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@unique([provider, providerAccountId])
    @@index([userId])
}

model Session {
    id           String   @id @default(cuid())
    sessionToken String   @unique
    userId       String
    expires      DateTime
    user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@index([userId])
}

model VerificationToken {
    identifier String
    token      String   @unique
    expires    DateTime

    @@unique([identifier, token])
}

model Profile {
    id             String  @id @default(cuid())
    userId         String  @unique
    username       String  @unique
    content        String? @db.Text // Legacy MDX content (optional, for backward compatibility)
    published      Boolean @default(false)
    views          Int?    @default(0) // Legacy view counter (optional)
    theme          String? // Theme identifier (e.g., "minimal", "modern")
    customDomain   String? // Custom domain for Pro users
    seoTitle       String? // Custom SEO title
    seoDescription String? @db.Text // Custom SEO description
    seoKeywords    String? // Custom SEO keywords
    removeBranding Boolean @default(false) // Pro feature

    // Public Resume Fields - Professional Identity
    displayName     String? // Display name (can differ from username)
    headline        String? // Professional headline/tagline (e.g., "Senior Software Engineer")
    location        String? // Geographic location (e.g., "San Francisco, CA")
    profilePhotoUrl String? // URL to profile photo/avatar
    accentColor     String? // Hex color for accent/branding (e.g., "#3b82f6")
    layoutStyle     String? // Layout preference (e.g., "minimal", "modern", "compact")

    // Social Links
    githubUrl   String? // GitHub profile URL
    linkedinUrl String? // LinkedIn profile URL
    websiteUrl  String? // Personal website/portfolio URL
    twitterUrl  String? // Twitter/X profile URL

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    user        User                @relation(fields: [userId], references: [id], onDelete: Cascade)
    sections    ProfileSection[]
    experiences ProfileExperience[] // Professional experiences (max 3)
    analytics   Analytics[]

    @@index([username])
    @@index([userId])
    @@index([published])
}

model ProfileSection {
    id        String   @id @default(cuid())
    profileId String
    // Section types: "hero", "about", "skills", "experience", "projects", "education", "links", "certifications", "mdx"
    // Each type has a strict JSON schema defined in lib/profile-sections.ts
    type      String
    // JSON content structure varies by type:
    // - hero: { fullName, title, tagline, location }
    // - about: { summary }
    // - skills: { categories: [{ name, items: [] }] }
    // - experience: { items: [{ company, role, startDate, endDate, description, techStack }] }
    // - projects: { items: [{ name, description, role, techStack, liveUrl, githubUrl }] }
    // - education: { items: [{ degree, institution, startYear, endYear }] }
    // - links: { items: [{ type, url }] } where type is "github" | "linkedin" | "portfolio" | "email" | "twitter"
    // - certifications: { items: [{ name, issuer, date, url }] }
    // - mdx: { mdx: string } (Pro feature)
    content   Json
    order     Int      @default(0) // Order of sections (lower = appears first)
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    profile Profile @relation(fields: [profileId], references: [id], onDelete: Cascade)

    @@index([profileId])
    @@index([profileId, order])
}

model ProfileExperience {
    id          String   @id @default(cuid())
    profileId   String
    company     String // Company name
    role        String // Job title/role
    startDate   String // Start date (ISO format or "YYYY-MM")
    endDate     String? // End date (null for current position)
    description String?  @db.Text // Job description/achievements (Markdown supported)
    techStack   String[] // Technologies used
    location    String? // Job location
    order       Int      @default(0) // Order of experiences (0 = most recent)
    createdAt   DateTime @default(now())
    updatedAt   DateTime @updatedAt

    profile Profile @relation(fields: [profileId], references: [id], onDelete: Cascade)
    // Enforce max 3 experiences per profile at application level

    @@index([profileId])
    @@index([profileId, order])
}

model Analytics {
    id        String   @id @default(cuid())
    profileId String
    eventType String // "view", "click", "download", "contact"
    referrer  String? // Where the traffic came from
    userAgent String? // Browser/device info
    ipAddress String? // IP address (hashed for privacy)
    metadata  Json? // Additional event metadata
    createdAt DateTime @default(now())

    profile Profile @relation(fields: [profileId], references: [id], onDelete: Cascade)

    @@index([profileId])
    @@index([profileId, eventType])
    @@index([createdAt])
}
